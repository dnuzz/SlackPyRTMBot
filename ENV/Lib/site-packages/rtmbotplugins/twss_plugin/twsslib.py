from __future__ import print_function
from __future__ import unicode_literals

import io
import os
import sys
from nltk.classify import PositiveNaiveBayesClassifier
import pickle
import datetime

class TWSSlib:
    positive_training_data = [] # [(sentence 1, bool), (sentence 2, bool), ... ]
    negative_training_data = []
    classifier = None

    def __init__(self, sentence=None, positive_corpus_file=None, negative_corpus_file=None):
        if positive_corpus_file and negative_corpus_file:
            self.import_training_data(positive_corpus_file, negative_corpus_file)
        else:
            self.import_training_data()
        if sentence:
            self.__call__(sentence)


    def __call__(self, sentence):
        return self.is_twss(sentence)

    def features(sentence):
        words = sentence.lower().split()
        return dict(('contains(%s)' % w, True) for w in words)
    
    def import_training_data(self,
            positive_corpus_file=os.path.join(os.path.dirname(__file__),
                'positive.txt'),
            negative_corpus_file=os.path.join(os.path.dirname(__file__),
                'negative.txt')
            ):
        
        # This method imports the positive and negative training data from the
        # two corpus files and creates the training data list. 
        try:
            self.load()
        except IOError:
            print('Failed to load pickled file.')


        positive_corpus = open(positive_corpus_file)
        negative_corpus = open(negative_corpus_file)


        for line in positive_corpus:
            self.positive_training_data.append(line)

        for line in negative_corpus:
            self.negative_training_data.append(line)

    def train(self):
        
        # This method generates the classifier. This method assumes that the
        # training data has been loaded
        
        if not self.positive_training_data and self.negative_training_data:
            self.import_training_data()

        positive_training = list(map(self.features(), self.positive_training_data))
        negative_training = list(map(self.features(), self.negative_training_data))

        self.classifier = PositiveNaiveBayesClassifier.train(positive_training,negative_training)

    def is_twss(self, phrase):
        
        # The magic function- this accepts a phrase and tells you if it
        # classifies as an entendre
        
        featureset = self.features(phrase)
        return self.classifier.classify(featureset)

    def save(self, filename='classifier.dump'):
        
        # Pickles the classifier and dumps it into a file
        
        ofile = open(filename,'w+')
        pickle.dump(self.classifier, ofile)
        ofile.close()
        
    def load(self, filename='classifier.dump'):
        
        # Unpickles the classifier used
        
        ifile = open(filename, 'r+')
        self.classifier = pickle.load(ifile)
        ifile.close()
